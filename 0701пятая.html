<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аутентификация и авторизация</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.5;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .definition {
            margin-bottom: 20px;
        }
        
        .term {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .description {
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Аутентификация соединений с сервером<br>Авторизация логинов для подключения к базам данных</h1>
    
    <div class="card">
        <h2>Аутентификация vs. Авторизация: Краткое различие</h2>
        
        <ul>
            <li><strong>Аутентификация (Authentication - AuthN):</strong> Процесс проверки подлинности пользователя.
                <br>Ответ на вопрос "Кто вы?". Это проверка логина/пароля, отпечатка пальца, Face ID и т.д.</li>
            <li><strong>Авторизация (Authorization - AuthZ):</strong> Процесс проверки прав пользователя на выполнение определенных действий.
                <br>Ответ на вопрос "Что вам разрешено делать?". Это проверка ролей (админ, модератор, пользователь) и разрешений.</li>
        </ul>
        
        <div class="analogy">
            <h3>Простая аналогия:</h3>
            <ol>
                <li>Вы предъявляете паспорт на ресепшене отеля → <strong>Аутентификация</strong> (доказали, что вы это вы).</li>
                <li>Вам выдают ключ от номера 505, но не от номера 506 → <strong>Авторизация</strong> (определили, к чему у вас есть доступ).</li>
            </ol>
        </div>
    </div>
    
    <div class="card">
        <h2>Часть 1: Аутентификация соединений с сервером</h2>
        <p>Здесь речь идет о том, как ваше веб-приложение (клиент) доказывает свою подлинность серверу, на котором работает backend. Это особенно важно для API.</p>
        
        <h3>Распространенные методы аутентификации сервер-сервер или клиент-сервер:</h3>
        
        <h4>1. API Keys (Ключи API)</h4>
        <ul>
            <li><strong>Как работает:</strong> Простой длинный уникальный токен, который клиент передает с каждым запросом (обычно в заголовке X-API-Key или как параметр запроса).</li>
            <li><strong>Плюсы:</strong> Простота реализации и использование.</li>
            <li><strong>Минусы:</strong> Низкая безопасность. Ключ часто передается открыто, его компрометация дает полный доступ. Никогда не используйте для аутентификации пользователей! Подходит для аутентификации сервисов между собой в доверенной среде.</li>
        </ul>
        
        <h4>2. JWT (JSON Web Tokens)</h4>
        <ul>
            <li><strong>Как работает:</strong>
                <ol>
                    <li>Пользователь логинится (отправляет логин/пароль).</li>
                    <li>Сервер проверяет данные, создает JWT-токен (подписанный цифровой подписью) и отдает его клиенту.</li>
                    <li>Клиент сохраняет токен (часто в LocalStorage или Cookies) и передает его в заголовке Authorization: Bearer &lt;токен&gt; при каждом последующем запросе.</li>
                    <li>Сервер проверяет подпись токена и извлекает из него данные (например, user id). Ему не нужно хранить сессию на сервере (stateless).</li>
                </ol>
            </li>
            <li><strong>Плюсы:</strong> Масштабируемость (не требует хранения сессий на сервере), удобство для мобильных и SPA-приложений.</li>
            <li><strong>Минусы:</strong> Сложность с немедленной инвалидацией токена (пока не истечет его срок жизни).</li>
        </ul>
        
        <h4>3. OAuth 2.0 / OpenID Connect</h4>
        <ul>
            <li><strong>Как работает:</strong> Делегированная аутентификация. Пользователь аутентифицируется на доверенном сервисе (например, Google, GitHub, Facebook), который затем выдает вашему приложению токен доступа.</li>
            <li><strong>Плюсы:</strong> Пользователям не нужно создавать новый пароль. Высокий уровень безопасности, так как пароли обрабатываются крупными провайдерами.</li>
            <li><strong>Минусы:</strong> Более сложная реализация на стороне backend.</li>
        </ul>
        
        <h4>4. Аутентификация на основе сессий (Cookies)</h4>
        <ul>
            <li><strong>Как работает:</strong>
                <ol>
                    <li>Пользователь логинится.</li>
                    <li>Сервер создает запись сессии в базе данных или in-memory хранилище (например, Redis) и отправляет клиенту идентификатор сессии (Session ID) в cookie (с флагами HttpOnly, Secure).</li>
                    <li>Браузер автоматически отправляет этот cookie с каждым запросом.</li>
                    <li>Сервер проверяет ID сессии в своем хранилище.</li>
                </ol>
            </li>
            <li><strong>Плюсы:</strong> Простота инвалидации сессии (удалил запись — доступ закрыт). Безопаснее хранения JWT в LocalStorage.</li>
            <li><strong>Минусы:</strong> Требует stateful-сервера и хранения сессий, что может усложнить масштабирование.</li>
        </ul>
    </div>
    
    <div class="card">
        <h2>Часть 2: Авторизация логинов для подключения к базам данных</h2>
        <p>Здесь речь идет о том, как ваше backend-приложение подключается к СУБД (MySQL, PostgreSQL, MongoDB и т.д.). Это служебная, а не пользовательская авторизация.</p>
        
        <h3>Ключевые принципы:</h3>
        
        <h4>1. Принцип наименьших привилегий (Principle of Least Privilege)</h4>
        <ul>
            <li>Это золотое правило. Учетная запись, которую использует ваше приложение для подключения к БД, должна иметь ровно те права, которые ей необходимы, и не более.</li>
            <li><strong>Пример:</strong> Если ваше приложение только читает данные из таблицы articles, его пользователь БД должен иметь право только SELECT на эту таблицу, но не INSERT, UPDATE, DELETE или DROP.</li>
        </ul>
        
        <h4>2. Использование разных учетных записей для разных целей</h4>
        <ul>
            <li>Не используйте одну супер-учетку (root/admin) для всего.</li>
            <li>Создайте отдельного пользователя БД специально для вашего приложения.</li>
            <li>Для разных сервисов (основное приложение, скрипты миграции, analytics) можно создать разных пользователей с разными правами.</li>
        </ul>
        
        <h4>3. Безопасное хранение учетных данных</h4>
        <ul>
            <li>Никогда не храните логины/пароли от БД в коде приложения (в гите)!</li>
            <li>Используйте переменные окружения (Environment Variables) или секреты (Secrets):
                <ul>
                    <li>Локально: файл .env (который добавлен в .gitignore).</li>
                    <li>На продакшене: используйте механизмы вашего хостинга/платформы (Environment Variables в Heroku, Secrets в Kubernetes, AWS Secrets Manager, HashiCorp Vault).</li>
                </ul>
            </li>
        </ul>
        
        <p><strong>Пример для Node.js и .env:</strong></p>
        <pre><code># Файл .env
DB_HOST=localhost
DB_PORT=5432
DB_NAME=mydatabase
DB_USER=myapp_user
DB_PASSWORD=very_strong_password_123</code></pre>
        
        <pre><code>// Код приложения
const { Pool } = require('pg');

const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
});</code></pre>
        
        <h4>4. Использование SSL/TLS для подключения к БД</h4>
        <ul>
            <li>Особенно критично, если ваша БД находится на удаленном сервере (не на том же хосте, что и приложение).</li>
            <li>Это шифрует весь трафик между приложением и СУБД, защищая данные от перехвата.</li>
        </ul>
    </div>
    
    <div class="card">
        <h2>Практическое задание для студентов:</h2>
        
        <h3>1. Создайте безопасного пользователя БД:</h3>
        <ul>
            <li>Подключитесь к вашей СУБД (например, PostgreSQL) из-под пользователя postgres.</li>
            <li>Создайте новую базу данных: <code>CREATE DATABASE myapp;</code></li>
            <li>Создайте пользователя: <code>CREATE USER myapp_user WITH PASSWORD 'secure_password';</code></li>
            <li>Дайте ему только необходимые права только на эту БД: <code>GRANT CONNECT, SELECT, INSERT, UPDATE ON DATABASE myapp TO myapp_user;</code> (список прав нужно уточнить под вашу задачу).</li>
            <li>Настройте ваше приложение на подключение с этими credentials.</li>
        </ul>
        
        <h3>2. Настройте переменные окружения:</h3>
        <ul>
            <li>Создайте файл .env в корне вашего проекта.</li>
            <li>Добавьте в него строки с данными для подключения к БД (как в примере выше).</li>
            <li>Убедитесь, что файл .env добавлен в .gitignore.</li>
            <li>Настройте ваше приложение (на любом языке) читать эти переменные.</li>
        </ul>
    </div>
    
    <div class="card">
        <h2>Итог:</h2>
        <p>Всегда разделяйте аутентификацию пользователей вашего приложения и аутентификацию самого приложения для доступа к БД. Для обоих случаев применяйте принцип наименьших привилегий и никогда не храните секреты в коде.</p>
    </div>
</body>
</html>