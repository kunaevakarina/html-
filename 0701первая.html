<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аутентификация соединений с сервером. Авторизация логинов для подключения к базам данных</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.5;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .definition {
            margin-bottom: 20px;
        }
        
        .term {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .description {
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <h1></h1>

    <h2>Аутентификация vs. Авторизация: Краткое различие</h2>
    
    <ul>
        <li><strong>Аутентификация (Authentication - AuthN):</strong> Процесс <strong>проверки подлинности</strong> пользователя. Ответ на вопрос "<strong>Кто вы?</strong>". Это проверка логина/пароля, отпечатка пальца, Face ID и т.д.</li>
        <li><strong>Авторизация (Authorization - AuthZ):</strong> Процесс <strong>проверки прав</strong> пользователя на выполнение определенных действий. Ответ на вопрос "<strong>Что вам разрешено делать?</strong>". Это проверка ролей (админ, модератор, пользователь) и разрешений.</li>
    </ul>

    <h3>Простая аналогия:</h3>
    <ol>
        <li>Вы предъявляете паспорт на ресепшене отеля → <strong>Аутентификация</strong> (доказали, что вы это вы).</li>
        <li>Вам выдают ключ от номера 505, но не от номера 506 → <strong>Авторизация</strong> (определили, к чему у вас есть доступ).</li>
    </ol>

    <h2>Часть 1: Аутентификация соединений с сервером</h2>
    
    <p>Здесь речь идет о том, как <strong>ваше веб-приложение (клиент)</strong> доказывает свою подлинность <strong>серверу</strong>, на котором работает backend. Это особенно важно для API.</p>

    <h3>Распространенные методы аутентификации сервер-сервер или клиент-сервер:</h3>

    <h4>1. API Keys (Ключи API)</h4>
    <ul>
        <li><strong>Как работает:</strong> Простой длинный уникальный токен, который клиент передает с каждым запросом (обычно в заголовке X-API-Key или как параметр запроса).</li>
        <li><strong>Плюсы:</strong> Простота реализации и использование.</li>
        <li><strong>Минусы:</strong> Низкая безопасность. Ключ часто передается открыто, его компрометация дает полный доступ. <strong>Никогда не используйте для аутентификации пользователей!</strong> Подходит для аутентификации сервисов между собой в доверенной среде.</li>
    </ul>

    <h4>2. JWT (JSON Web Tokens)</h4>
    <ul>
        <li><strong>Как работает:</strong>
            <ol>
                <li>Пользователь логинится (отправляет логин/пароль).</li>
                <li>Сервер проверяет данные, создает <strong>JWT-токен</strong> (подписанный цифровой подписью) и отдает его клиенту.</li>
                <li>Клиент сохраняет токен (часто в LocalStorage или Cookies) и передает его в заголовке Authorization: Bearer &lt;токен&gt; при каждом последующем запросе.</li>
                <li>Сервер проверяет подпись токена и извлекает из него данные (например, user id). <strong>Ему не нужно хранить сессию на сервере</strong> (stateless).</li>
            </ol>
        </li>
        <li><strong>Плюсы:</strong> Масштабируемость (не требует хранения сессий на сервере), удобство для мобильных и SPA-приложений.</li>
        <li><strong>Минусы:</strong> Сложность с немедленной инвалидацией токена (пока не истечет его срок жизни).</li>
    </ul>

    <h4>3. OAuth 2.0 / OpenID Connect</h4>
    <ul>
        <li><strong>Как работает:</strong> Делегированная аутентификация. Пользователь аутентифицируется на доверенном сервисе (например, Google, GitHub, Facebook), который затем выдает вашему приложению токен доступа.</li>
        <li><strong>Плюсы:</strong> Пользователям не нужно создавать новый пароль. Высокий уровень безопасности, так как пароли обрабатываются крупными провайдерами.</li>
        <li><strong>Минусы:</strong> Более сложная реализация на стороне backend.</li>
    </ul>

    <h4>4. Аутентификация на основе сессий (Cookies)</h4>
    <ul>
        <li><strong>Как работает:</strong>
            <ol>
                <li>Пользователь логинится.</li>
                <li>Сервер создает запись <strong>сессии</strong> в базе данных или in-memory хранилище (например, Redis) и отправляет клиенту идентификатор сессии (Session ID) в cookie (с флагами HttpOnly, Secure).</li>
                <li>Браузер автоматически отправляет этот cookie с каждым запросом.</li>
                <li>Сервер проверяет ID сессии в своем хранилище.</li>
            </ol>
        </li>
        <li><strong>Плюсы:</strong> Простота инвалидации сессии (удалил запись — доступ закрыт). Безопаснее хранения JWT в LocalStorage.</li>
        <li><strong>Минусы:</strong> Требует stateful-сервера и хранения сессий, что может усложнить масштабирование.</li>
    </ul>

    <h2>Часть 2: Авторизация логинов для подключения к базам данных</h2>
    
    <p>Здесь речь идет о том, как <strong>ваше backend-приложение</strong> подключается к <strong>СУБД</strong> (MySQL, PostgreSQL, MongoDB и т.д.). Это служебная, а не пользовательская авторизация.</p>

    <h3>Ключевые принципы:</h3>

    <h4>1. Принцип наименьших привилегий (Principle of Least Privilege)</h4>
    <ul>
        <li>Это золотое правило. Учетная запись, которую использует ваше приложение для подключения к БД, должна иметь <strong>ровно те права, которые ей необходимы, и не более</strong>.</li>
        <li><strong>Пример:</strong> Если ваше приложение только читает данные из таблицы articles, его пользователь БД должен иметь право только SELECT на эту таблицу, но не INSERT, UPDATE, DELETE или DROP.</li>
    </ul>

    <h4>2. Использование разных учетных записей для разных целей</h4>
    <ul>
        <li>Не используйте одну супер-учетку (root/admin) для всего.</li>
        <li>Создайте отдельного пользователя БД специально для вашего приложения.</li>
        <li>Для разных сервисов (основное приложение, скрипты миграции, analytics) можно создать разных пользователей с разными правами.</li>
    </ul>

    <h4>3. Безопасное хранение учетных данных</h4>
    <ul>
        <li><strong>Никогда не храните логины/пароли от БД в коде приложения (в гите)!</strong></li>
        <li><strong>Используйте переменные окружения (Environment Variables) или секреты (Secrets):</strong>
            <ul>
                <li>Локально: файл .env (который добавлен в .gitignore).</li>
                <li>На продакшене: используйте механизмы вашего хостинга/платформы (Environment Variables в Heroku, Secrets в Kubernetes, AWS Secrets Manager, HashiCorp Vault).</li>
            </ul>
        </li>
    </ul>

    <h5>Пример для Node.js и .env:</h5>
    <pre>
# Файл .env
DB_HOST=localhost
DB_PORT=5432
DB_NAME=mydatabase
DB_USER=myapp_user
DB_PASSWORD=very_strong_password_123
    </pre>

    <pre>
// Код приложения
const { Pool } = require('pg');
const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
});
    </pre>

    <h4>4. Использование SSL/TLS для подключения к БД</h4>
    <ul>
        <li>Особенно критично, если ваша БД находится на удаленном сервере (не на том же хосте, что и приложение).</li>
        <li>Это шифрует весь трафик между приложением и СУБД, защищая данные от перехвата.</li>
    </ul>

    <h2>Практическое задание для студентов:</h2>

    <h3>1. Создайте безопасного пользователя БД:</h3>
    <ul>
        <li>Подключитесь к вашей СУБД (например, PostgreSQL) из-под пользователя postgres.</li>
        <li>Создайте новую базу данных: CREATE DATABASE myapp;</li>
        <li>Создайте пользователя: CREATE USER myapp_user WITH PASSWORD 'secure_password';</li>
        <li>Дайте ему только необходимые права <strong>только на эту БД</strong>: GRANT CONNECT, SELECT, INSERT, UPDATE ON DATABASE myapp TO myapp_user; (список прав нужно уточнить под вашу задачу).</li>
        <li>Настройте ваше приложение на подключение с этими credentials.</li>
    </ul>

    <h3>2. Настройте переменные окружения:</h3>
    <ul>
        <li>Создайте файл .env в корне вашего проекта.</li>
        <li>Добавьте в него строки с данными для подключения к БД (как в примере выше).</li>
        <li>Убедитесь, что файл .env добавлен в .gitignore.</li>
        <li>Настройте ваше приложение (на любом языке) читать эти переменные.</li>
    </ul>

    <h2>Итог:</h2>
    <p>Всегда разделяйте аутентификацию пользователей вашего приложения и аутентификацию самого приложения для доступа к БД. Для обоих случаев применяйте принцип наименьших привилегий и никогда не храните секреты в коде.</p>
</body>
</html>